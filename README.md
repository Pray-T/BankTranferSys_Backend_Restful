| 인사말 |

안녕하세요, 먼저 귀한시간을 내어 저의 깃허브에 방문해주신것에 대한 감사를 먼저 드립니다.<br/>저는 팀의 일원으로서 팀원들과 함께 좋은 에너지와 좋은 시너지를 만들며 일을 하고 싶고 동시에 개인적으로 혼자 고민하는 시간을 갖고 그것을 토대로 성장하는 전문가로서의 역량을 기르고자 하는 개발자입니다.
<br/>해당 포트폴리오는 Restful하게 은행의 이체시스템의 백엔드를 구현한 것이며 MySQL의 트랜잭션과 인덱스와 관련된 포트폴리오입니다.<br/>



##
| 이름 | 최성욱 |

| 이메일 | cenmot@naver.com |





## MYSQL의 트랜잭션(정합성이 중요한 이체시스템에서 격리화 단계는 어떻게 설정해야할까?)


<br/>
<br/>

-케이스: 정합성이 중요한 이체 시스템에서 정정합성을 최고 우선시하여 격리화 최고 단계인 Serializable을 사용한 케이스.

읽기에 있어서 공유 잠금을 가진 Serializable을 사용하여 같은 레코드에 접근한 결과

-예상 결과: 시간은 좀 걸리지만 정합성이 뛰어나 이체시스템에 적합한 격리단계라고 판단됨.

-실제 결과에서 발생한 문제점:  레코드에 대해서 동시에 요청을 한 경우 나중에 요청된 것들은 그 앞의 트랜잭션이 끝나기까지 대기하다가 대기시간 타임 아웃으로 요청이 실행되지 않음.


  같은 레코드에 대하여 요청한 쿼리:
  
 <img width="527" height="70" alt="스크린샷 2025-12-12 211329" src="https://github.com/user-attachments/assets/46cb3a54-788c-4019-ad8f-d430c0390ce6" />
 
 같은 레코드에 위와 같은 요청이 동시에 들어온다면 추후에 들어온 요청은 먼저번의 요청이 끝날 때까지 대기하다가 타임 아웃을 발생시킬 확률이 존재. 또한 모든 조회 쿼리가 공유 잠금이 걸려있어 동시 읽기 성능이 크게 저하됨. 이는 대기시간 증가와 대용량 처리에 있어서 문제가 발생할 가능성이 큽니다.

타임아웃이 발생하여 연결이 끊어짐:

<img width="848" height="102" alt="스크린샷 2025-12-12 222936" src="https://github.com/user-attachments/assets/33e9edc3-fff0-4148-8d44-d57be80b7031" />


-해결 방법: 격리화 수준을 한 단계 낮춰서 Repeteable Read로 변경하고 레코드의 변경이 필요한 쿼리 요청은 Select ... for Update 을 통하여 읽기 성능에는 저하를 발생시키지 않고 레코드의 변경이 필요한 요청만 해당 레코드를 잠금하여 정합성과 Phantom Read를 예방합니다. 또한 @Version과 멱등성키(Idempotency-key)의 사용으로 여러 번의 보호작업이 들어감으로써 안정성을 더 확보합니다.

@Version이란? 낙관적 잠금을 위해 사용되는 필드로써 엔티티가 수정되면 자동적으로 증가합니다. 그리하여 동시에 들어오는 요청중 첫 반쩨 요청 이후에 들어오는 요청은 트랜잭션 완료 직전 version의 숫자를 비교하여 처음의 version과 숫자가 다르면 트랜잭션이 완료되지 않게 합니다.


멱등성키란(Idempotency-key)? 이체 요청시 고유한 문자열을 헤더에 포함하여 이 문자열을 확인하여 이 요청이 이미 처리된 요청인지 아니면 처리해야할 새로운 요청인지 확인하는 역할을 합니다. 이를 통해 요청자는 안전하게 재시도를 할 수 있고 이중 결제나 이중 이체와 같은 중복을 방지할 수 있습니다.

<img width="225" height="34" alt="스크린샷 2025-12-12 214003" src="https://github.com/user-attachments/assets/eab7d6aa-ff70-4d9d-9acf-0a32c04b92a2" />

해당 포트폴리오의 멱등성키의 지속시간은 10초이며 10초 이내의 요청은 같은 요청으로 간주하여 중복 요청을 예방합니다.




## MYSQL의 인덱스(MYSQL에서 성능과 중요한 연관이 있는 인덱스 기능에 관하여)
- 조회 성능과 밀접적으로 관련이 있는 요소로써 Select...where 쿼리에 맞는 레코드를 DB전체를 스캔하지 않고 빠르게 찾을 수 있습니다. 인덱스는 저장 작업에서는 손해를 보지만 읽기 속도를 높이는 요소입니다. 하지만 DB에서 대부분의 작업은 저장작업이 아닌 읽기 작업임을 감안한다면 적절한 인덱스의 생성은 빠른 응답시간을 보장합니다.

-인덱스 생성 없이 약 200만건의 데이터중 조건에 맞는 데이터의 조회시간은 0.031sec이지만 인덱스 생성 후의 조회시간은 0.016sec으로써 약 48.4%의 성능개선이 이뤄졌습니다. 쌓이는 데이터의 양이 늘어날수록, 조회 횟수가 더 잦을수록 성능 개선의 효과는 더욱 커집니다.

인덱스 사용 전:
<img width="1702" height="65" alt="스크린샷 2025-12-12 220726" src="https://github.com/user-attachments/assets/bf9fe8a9-1de2-4f82-9fd1-a81669512276" />

인덱스 사용 후:
<img width="1678" height="39" alt="스크린샷 2025-12-12 222358" src="https://github.com/user-attachments/assets/41d3d42b-3a65-44e6-838d-a7721c6c34bb" />




이상으로 저의 깃헙 Readme를 마치겠습니다, 읽어주셔서 감사합니다.
