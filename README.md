| 인사말 |

안녕하세요, 먼저 귀한시간을 내어 저의 깃허브에 방문해주신것에 대한 감사를 먼저 드립니다.<br/>저는 팀의 일원으로서 팀원들과 함께 좋은 에너지와 좋은 시너지를 만들며 일을 하고 싶고 동시에 개인적으로 혼자 고민하는 시간을 갖고 그것을 토대로 성장하는 전문가로서의 역량을 기르고자 하는 개발자입니다.
<br/>해당 포트폴리오는 백엔드로서 RestFul api로 은행의 이체시스템을 구현한 것이며 MySQL의 트랜잭션과 인덱스와 관련된 포트폴리오입니다.<br/>



##
| 이름 | 최성욱 |

| 이메일 | cenmot@naver.com |





## MYSQL의 트랜잭(-정합성이 중요한 이체시스템에서 격리화 단계는 어떻게 설정해야할까?)


<br/>
<br/>

-케이스: 정합성이 중요한 이체 시스템에서 정정합성을 최고 우선시하여 격리화 최고 단계인 Serializable을 사용한 케이스.

레코드를 읽는것부터 잠그는 읽기 잠금을 가진 Se를 사용하여 이체 기능을 사용한 결과

-예상 결과: 시간은 좀 걸리지만 정합성이 뛰어나 이체시스템에 적합한 격리화 단계로 생각됨.

-실제 결과: 데드락이 발생하여 앱이 제기능을 수행하지 못함

-문제점: 한 레코드에 대해서 동시에 요청을 한 경우 두 번째 요청은 첫 번째의 트랜잭션이 끝나기까지 대기하다가 대기시간 타임 아웃으로 요청이 실행되지 않음. 또한 단순 조회 쿼리에도 잠금이 발생하여 가용성이 매우 떨어짐.

-해결 방법: 격리화 수준을 한 단계 낮춰서 Repeteable Read로 변경하고 레코드의 변경이 필요한 쿼리 요청은 Select ... for Update 을 통하여 단순 조회 쿼리는 잠금이 발생하지 않고 레코드의 변경이 필요한 요청만 해당 레코드를 잠금하여 정합성과 Phantom Read를 예방함.

-의문점: 그렇다면 요청1이 레코드 A에 트랜잭션 도중 요청2가 레코드 A에 요청하여 잔액이 부족한데도 이체를 요청한다면 어떻게 될까?
-의문에 대한 결과: 단순 조회는 잠금이 되지 않지만 이체 요청을 위한 요청2는  Select ... for Update로 쿼리를 날리게 되어서 요청1의 결과가 끝날 때까지 대기하여야 한다. 그리하여 잔액의 결과에 따라서 요청2가 수행된다.


## MYSQL의 인덱스(MYSQL에서 성능과 중요한 연관이 있는 인덱스 기능에 관하여)
- 


## 프로토콜 및 기능 개요



이상으로 저의 깃헙 Readme를 마치겠습니다, 읽어주셔서 감사합니다.
